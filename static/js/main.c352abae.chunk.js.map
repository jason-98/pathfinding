{"version":3,"sources":["path_icon_white.png","Square.js","Board.js","ControlPanel.js","Key.js","Header.js","graph.js","algorithms.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","Square","props","buttonClass","value","className","onMouseDown","onMouseEnter","onMouseUp","Board","state","isMouseDown","i","index","this","squares","handleMouseEnter","i_start","i_end","row","push","renderSquare","rows","rowLength","Math","ceil","sqrt","length","renderRow","min","setState","React","Component","Option","Select","marks","0","style","color","label","33","66","100","formatter","ControlPanel","algorithm","epsilon","onAlgorithmChange","position","onEpsilonChange","span","md","lg","defaultValue","onSelect","handleAlgorithmChange","tipFormatter","step","onChange","handleEpsilonChange","href","xs","gutter","block","type","onClick","onRunPressed","onResetPressed","Key","justify","align","offset","sm","xl","console","log","Header","expand","src","logo","width","height","alt","navbar","active","Vertex","id","isVisitable","fcost","hcost","prev","edges","Edge","neighbourVertex","cost","Graph","size","sourceIndex","targetIndex","wallMask","Array","fill","unprocessedVertices","build","processedVerticies","finished","eplison","vertexSet","m","rowIndex","floor","colIndex","n","max","p","isDiagonal","neighbour","targetRowIndex","targetColIndex","pow","nextClosestVertex","currentIndex","minDist","indexOfMin","dist","getTotalCost","findIndexOfMinTotalCost","u","splice","j","v","a_star","prevVertex","undefined","nextVertex","backtrackVertex","depth_first","findIndexOfMinHCost","greedy_best_first","findIndexOfMinFcost","dijkstra","isFinished","processNextVertex","pathToTarget","t","slice","pop","unshift","grid","getPath","k","reset","processAllVerticies","prevSize","prevRowLength","newRowLength","prevTarget","prevTargetRow","prevTargetCol","newTarget","newTargetRow","newTargetCol","prevSource","prevSourceRow","prevSourceCol","newSource","newSourceRow","newSourceCol","newWallMask","currentRowInNew","currentColInNew","App","graph","isSourceMoving","isTargetMoving","Promise","resolve","setTimeout","then","animateSteps","toGrid","isWall","clearWall","placeWall","placementIsWall","changeSourceIndex","changeTargetIndex","changeAlgorithm","changeEpsilon","clear","maxCols","window","innerWidth","numCols","round","numSquares","resize","handleScreenResize","addEventListener","bind","removeEventListener","handleRunPressed","handleResetPressed","handleMouseDown","handleMouseUp","handleTouchStart","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c352abae.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/path_icon_white.eeb56e80.png\";","import React from 'react';\nimport './Square.css';\n\n/**\n * Function responsible for defining an individual square in board.\n */\nfunction Square(props) {\n  let buttonClass\n  if(props.value===1){\n    buttonClass = \"square-start\"\n  } else if (props.value===2) {\n    buttonClass = \"square-end\"\n  } else if (props.value===3) {\n    buttonClass = \"square-wall\"\n  } else if (props.value===4) {\n    buttonClass = \"square-path\"\n  } else if (props.value===5) {\n    buttonClass = \"square-visited\"\n  }else{\n    buttonClass = \"square-default\"\n  }\n\n  return (\n    <button\n        className={\"square \"+buttonClass}\n        onMouseDown={props.onMouseDown}\n        onMouseEnter={props.onMouseEnter}\n        onMouseUp={props.onMouseUp}\n    >\n\n    </button>\n  );\n\n}\n\n//{props.index}\n\nexport default Square;\n","import React from 'react';\nimport Square from './Square';\nimport './Board.css';\n\n/**\n * Class representing the game board. This is formed by a grid of Squares.\n */\nclass Board extends React.Component {\n\n  /**\n   * Creates the game board.\n   */\n  constructor(props){\n    super(props)\n    this.state = {\n          isMouseDown: false,\n    };\n  }\n\n  /**\n   * Helper function to render an individual square.\n   *\n   * @param {number} i - Index of position in grid where square is created.\n   */\n  renderSquare(i) {\n    return (\n      <Square\n        index={i}\n        value={this.props.squares[i]}\n        onMouseEnter={() => this.handleMouseEnter(i)}\n        onMouseDown={() => this.props.onMouseDown(i)}\n        onMouseUp={() => this.props.onMouseUp(i)}\n      />\n    );\n  }\n\n  /**\n   * Helper function to render an entire row of squares.\n   *\n   * @param {number} i_start - Start index of position in grid.\n   * @param {number} i_end - End index of position in grid.\n   */\n  renderRow(i_start, i_end){\n    const row = []\n    for (var i = i_start; i < i_end; i++) {\n      row.push(this.renderSquare(i))\n    }\n\n    return(\n      <div className=\"board-row\">\n        {row}\n      </div>\n    );\n  }\n\n\n  /**\n   * Handles when mouse enters a new square. If the mouse is currently held\n   * down, bubble this event up, else do nothing.\n   *\n   * @param {number} i - Index of position in grid where event occured.\n   */\n  handleMouseEnter(i){\n\n    if(this.state.isMouseDown){\n        this.props.onMouseEnter(i)\n    }\n  }\n\n\n\n  /**\n   * Renders game board. \n   */\n  render() {\n\n    const rows = []\n    const rowLength = Math.ceil(Math.sqrt(this.props.squares.length))\n\n    for (var i = 0; i < this.props.squares.length; i+=rowLength) {\n      rows.push(this.renderRow(i,Math.min(i+rowLength, this.props.squares.length)))\n    }\n\n    return (\n        <div className=\"board\"\n          onMouseDown={()=> this.setState({ isMouseDown: true })}\n          onMouseUp={()=> this.setState({ isMouseDown: false })}\n          >\n          {rows}\n        </div>\n    );\n  }\n}\n\n/*\nprintConsole(message){\n  var console = this.state.console\n  console+=message+\"\\n\"\n  this.setState({\n    isMouseDown: this.state.isMouseDown,\n    console: console\n  })\n}\n\nimport Swipe from 'react-easy-swipe';\n\n//returning true from this functions prevents the view from scolling on swipe (for mobile)\nonSwipeMove(event) {\n  return true;\n}\n\n<Swipe onSwipeMove={this.onSwipeMove} >\n</Swipe>\n*/\n\nexport default Board;\n","import React from 'react';\nimport { Row, Col, Button, Select, Slider } from 'antd';\nimport './ControlPanel.css';\n\nconst { Option } = Select;\n\nconst marks = {\n  0: {\n    style: {\n      color: '#40A9FF', //'#f50'\n    },\n    label: <strong>Slower</strong>,\n    value: 0\n  },\n  33: { value: 1},\n  66: { value: 2},\n  100: {\n    style: {\n      color: '#40A9FF',\n    },\n    label: <strong>Faster</strong>,\n    value: 10\n  },\n};\n\n/**\n * Converts epsilon slider position into string label.\n *\n * @return {string} Formatted label.\n */\nfunction formatter(value) {\n  if(value<33){\n    return `${\"ε = 0\"}`;\n  } else if(value<66){\n    return `${\"ε = 1\"}`;\n  }else if(value<100){\n    return `${\"ε = 2\"}`;\n  }else {\n    return `${\"ε = 10\"}`;\n  }\n\n}\n\n\n/**\n * Class representing control panel which contains all control UI components.\n */\nclass ControlPanel extends React.Component {\n\n  /**\n   * Creates the control panel.\n   */\n  constructor(props) {\n      super(props);\n\n      this.state = {\n        algorithm: \"dijkstra\",\n        epsilon: 1,\n      }\n    }\n\n    /**\n     * Handle when current pathfinding algorithm is changed in the UI. Updates\n     * state and then bubbles up event.\n     *\n     * @param {string} algorithm - Name of the new algorithm in use.\n     */\n  handleAlgorithmChange(value){\n\n    this.setState({\n      algorithm: value,\n      epsilon: this.state.epsilon,\n    });\n\n    //breadth first search and dijkstra are equivalent on this type of graph, so just use dijkstra\n    if(value===\"breadth-first\"){\n        this.props.onAlgorithmChange(\"dijkstra\")\n    } else{\n        this.props.onAlgorithmChange(value)\n    }\n\n  }\n\n  /**\n   * Handle when epsilon value is changed in the UI. Updates state and then\n   * bubbles up event.\n   *\n   * @param {number} value - New value for epsilon.\n   */\n  handleEpsilonChange(position){\n    const value = marks[position].value\n    this.setState({\n      algorithm: this.state.algorithm,\n      epsilon: value,\n    });\n    this.props.onEpsilonChange(value)\n  }\n\n\n  /**\n   * Renders control panel.\n   */\n  render() {\n    return (\n      <div>\n        <div className=\"panel pl-4 pr-4 pb-4 pt-3\">\n\n          <Row>\n            <Col span={24}>\n              <h4 className=\"mb-1\"> Algorithm </h4>\n            </Col>\n          </Row>\n\n          <Row className=\"mb-3\">\n            <Col className=\"mb-1\" md={24} lg={24}> Select pathfinding algorithm: </Col>\n            <Col span={24}>\n              <Select className=\"select\" defaultValue=\"dijkstra\" onSelect={(value)=>this.handleAlgorithmChange(value)}>\n                <Option value=\"a-star\">A*</Option>\n                <Option value=\"dijkstra\">Dijkstra</Option>\n                <Option value=\"greedy-best-first\">Greedy Best-First Search</Option>\n                <Option value=\"depth-first\">Depth-First Search</Option>\n                <Option value=\"breadth-first\">Breadth-First Search</Option>\n\n              </Select>\n            </Col>\n          </Row>\n\n          <div className={this.state.algorithm!==\"a-star\" ? 'mb-2 hidden' : ''}>\n\n              <p className=\"text-small text-justify\">\n                <b> A* </b> (\"A-star\") works similarly to Dijkstra's Algorithm but uses a <b> heuristic function </b> to close in on the target more quickly. The algorithm works by maintaining two values at each node: 1) the exact distance g(n) from the source to the current node and 2) a heuristic h(n) that estimates the distance from the current node to the target. The algorithm determines which node to visit next by minimising the function <b> f(n) = g(n) + εh(n)</b>, where ε is a weighting factor that is applied to h(n) to observe how the heuristic affects the path that is selected [1].\n              </p>\n\n              <Row >\n                <Col md={24} lg={24}> Select heuristic weighting factor ε: </Col>\n                <Col className=\"pl-3 pr-3\" span={24}>\n                  <Slider tipFormatter={formatter} marks={marks} step={null} defaultValue={33} onChange={(position)=>this.handleEpsilonChange(position)}/>\n                </Col>\n              </Row>\n\n\n              <div className={this.state.epsilon!==0 ? 'mb-2 hidden' : ''}>\n                  <p className=\"text-small text-justify\">\n                      For the case ε=0, the heuristic function is removed and A* turns into Dijkstra's Algorithm which is guaranteed to find the shortest path.\n                  </p>\n              </div>\n\n              <div className={this.state.epsilon!==1 ? 'mb-2 hidden' : ''}>\n                  <p className=\"text-small text-justify\">\n                      For the case ε=1, A* will only follow the best path and never expand anything else, making it fast while still guaranteeing the shortest path.\n                  </p>\n              </div>\n\n              <div className={this.state.epsilon!==2 ? 'mb-2 hidden' : ''}>\n                  <p className=\"text-small text-justify\">\n                      For the case ε>1, A* is no longer guaranteed to find the shortest path, however this means that the algorithm will likely run faster.\n                  </p>\n              </div>\n\n              <div className={this.state.epsilon!==10 ? 'mb-2 hidden' : ''}>\n                  <p className=\"text-small text-justify\">\n                      For the case ε>>1, h(n) becomes large compared to g(n) and A* turns into Greedy Best-First Search.\n                  </p>\n              </div>\n\n              <p className=\"text-small text-justify\">\n                [1] Amit Patel (1997). Introduction to A*. <a href=\"http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html\"> [online]</a>\n              </p>\n          </div>\n\n          <div className={this.state.algorithm!==\"dijkstra\" ? 'mb-2 hidden' : ''}>\n              <Row className=\"mb-2\">\n                <Col span={24}>\n                    <p className=\"text-small text-justify\">\n                    <b> Dijkstra's algorithm </b> is used to find the shortest path between the source node and the target node in a graph. The algorithm works by starting at the source node and examining all its neighbouring nodes. These neighbour nodes have their own neighbour nodes which can be visited in turn. At each step, the algorithm visits the node the closest to the source  that has not yet been visited. The algorithm expands outward in this manner until the target node is reached [1]. Dijkstra's algorithm is <b> guaranteed to find the shortest path </b> between the source and target nodes.\n                    </p>\n\n\n                    <p className=\"text-small text-justify\">\n                      [1] cse.unt.edu. (2013). Dijkstra's algorithm. <a href=\"http://www.cse.unt.edu/~tarau/teaching/AnAlgo/Dijkstra%27s%20algorithm.pdf\"> [online] </a>\n                    </p>\n                </Col>\n              </Row>\n          </div>\n\n          <div className={this.state.algorithm!==\"greedy-best-first\" ? 'mb-2 hidden' : ''}>\n              <Row className=\"mb-2\">\n                <Col span={24}>\n                    <p className=\"text-small text-justify\">\n                      <b> Greedy Best-First Search </b> works by using an estimate, or heuristic, to determine which node to visit next. The heuristic is often a function of the distance between each node and the target node. Instead of visiting the node closest to the source node at each step, like in Dijkstra's Algorithm, the node closest to the target node is visited next [1]. This does <b>not guarantee to find the shortest path</b>, however, it runs much quicker than Dijkstra’s Algorithm because the path is guided towards the goal very quickly.\n                    </p>\n\n                    <p className=\"text-small text-justify\">\n                      [1] Amit Patel (1997). Dijkstra and Best-First Search. <a href=\"http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html#dijkstras-algorithm-and-best-first-search\"> [online]</a>\n                    </p>\n                </Col>\n              </Row>\n          </div>\n\n          <div className={this.state.algorithm!==\"depth-first\" ? 'mb-2 hidden' : ''}>\n              <Row className=\"mb-2\">\n                <Col span={24}>\n                    <p className=\"text-small text-justify\">\n                      <b> Depth-First Search </b> works by starting at the source node and exploring as far as possible along each branch before backtracking. This process continues until the target node is found [1].\n                    </p>\n\n                    <p className=\"text-small text-justify\">\n                      [1] General Depth First Search (2015). <a href=\"https://bradfieldcs.com/algos/graphs/depth-first-search/\"> [online] </a>\n                    </p>\n                </Col>\n              </Row>\n          </div>\n\n          <div className={this.state.algorithm!==\"breadth-first\" ? 'mb-2 hidden' : ''}>\n              <Row className=\"mb-2\">\n                <Col span={24}>\n                    <p className=\"text-small text-justify\">\n                        <b> Breadth-First Search</b> works by starting at the source node and visiting all its immediate neighbours. Once all immediate neighbours have been visited, the algorithm moves down a level and visits all the neighbour's neighbours, and so on. This continues until the target node is found. This process should sound similar to Dijkstra's Algorithm. Breadth-First Search is equivalent to Dijkstra's Algorithm for <b> unweighted </b> graphs. The grid of squares used in this visualisation is an example of an unweighted graph.\n                    </p>\n                </Col>\n              </Row>\n          </div>\n\n\n          <Row className=\"mt-0\">\n            <Col xs={24} lg={24}>\n                <h4 className=\"mb-1\"> Visualise </h4>\n                      <p className=\"text-small\">To visualise how the current pathfinding algorithm finds a path from the source to the target, click 'Play' below:</p>\n            </Col>\n          </Row>\n\n          <Row gutter={[16, 16]}>\n              <Col xs={12} lg={12} >\n                  <Button className=\"btn-run\" block type=\"primary\" onClick={()=>this.props.onRunPressed()}>\n                      Play\n                  </Button>\n              </Col>\n              <Col  xs={12} lg={12} >\n                  <Button className=\"btn-clear\" block type=\"danger\" onClick={()=>this.props.onResetPressed()} >\n                    Clear\n                  </Button>\n\n              </Col>\n          </Row>\n\n        </div>\n      </div>\n\n    );\n  }\n}\n\nexport default ControlPanel;\n\n\n/*\nThis algorithm was published by Edsger Dijkstra in 1959.\nis used to find the shortest path between between two nodes in a graph.\n*/\n\n/*\n<p className=\"text-small\"> Click and drag mouse to place walls in the grid. Drag source and target squares to change start and end positions. </p>\n<p className=\"text-small\">(on mobile touch source or target square, then touch new square to move). </p>\n*/\n\n\n/*\n<div>\n  <div className=\"panel p-3\">\n    <Container>\n\n      <Row >\n        <Col>\n          <h4 className=\"mb-2\"> Setup </h4>\n        </Col>\n      </Row>\n      <Row className=\"mb-3\">\n        <Col md=\"12\" lg=\"8\">Select algorithm:</Col>\n        <Col md=\"12\" lg=\"12\">\n        <FormSelect className=\"limit-height\" onChange={this.handleAlgorithmChange}>\n          <option value=\"dijkstra\">Dijkstra</option>\n          <option value=\"a-star\">A*</option>\n        </FormSelect>\n\n\n        </Col>\n      </Row>\n\n      <Row className=\"mb-4\">\n        <Col>\n          <p className=\"text-small text-justify\">\n          <b>Dijkstra's </b> algorithm (or Dijkstra's Shortest Path First algorithm, SPF algorithm)[1] is an algorithm for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.[2][3][4]\n          </p>\n        </Col>\n\n      </Row>\n\n\n      <Row>\n          <Col xs=\"6\" lg=\"6\">\n              <Button className=\"btn-run\" theme=\"primary\" onClick={()=>this.props.onRunPressed()}>\n                  Play\n              </Button>\n          </Col>\n          <Col xs=\"6\" lg=\"6\">\n              <Button className=\"btn-clear\" theme=\"danger\" onClick={()=>this.props.onResetPressed()} >\n                Reset\n              </Button>\n\n          </Col>\n      </Row>\n\n\n    </Container>\n  </div>\n\n\n</div>\n\n*/\n\n\n/*\n<Row>\n  <Col className=\"mb-1\">\n    Set animation speed:\n  </Col>\n</Row>\n<Row className=\"mb-2\">\n    <Col md=\"12\" lg=\"10\" >\n      <Slider className=\"mt-2 mb-2\" theme=\"light\" connect={[true, false]} start={[20]} range={{ min: 0, max: 100 }} />\n    </Col>\n    <Col md=\"12\" lg=\"2\">\n      Fast\n    </Col>\n</Row>\n<Row className=\"mb-3\">\n  <Col>\n      <p className=\"text-small\"> Drag slider far left for no animation </p>\n  </Col>\n\n</Row>\n*/\n","import React from 'react';\nimport { Row, Col } from 'antd';\n\nimport './ControlPanel.css';\nimport Square from './Square';\n\n/**\n * Class representing key which shows what each type of square represents.\n */\nclass Key extends React.Component {\n\n  /**\n   * Renders key.\n   */\n  render() {\n    return (\n      <div>\n        <div className=\"p-2 mb-4\">\n\n            <Row  type=\"flex\" justify=\"left\" align=\"top\">\n\n              <Col className=\"mb-1\" xs={{ span: 4, offset: 0}} sm={3} md={{ span: 2, offset: 2}} lg={{ span: 2, offset: 1}} xl={{ span: 2, offset: 2}}>\n                <Square\n                  index={0}\n                  value={1}\n                  onMouseEnter={() => console.log()}\n                  onMouseDown={() => console.log()}\n                  onMouseUp={() => console.log()}\n                />\n\n              </Col>\n              <Col xs={4} sm={3} md={1}>\n                  Source\n              </Col>\n\n              <Col className=\"mb-1\" xs={4} sm={3} md={2}>\n                <Square\n                  index={0}\n                  value={2}\n                  onMouseEnter={() => console.log()}\n                  onMouseDown={() => console.log()}\n                  onMouseUp={() => console.log()}\n                />\n\n              </Col>\n              <Col xs={4} sm={3} md={1}>\n                  Target\n              </Col>\n\n\n              <Col className=\"mb-1\" xs={4} sm={3} md={2}>\n                <Square\n                  index={0}\n                  value={0}\n                  onMouseEnter={() => console.log()}\n                  onMouseDown={() => console.log()}\n                  onMouseUp={() => console.log()}\n                />\n\n              </Col>\n              <Col xs={4} sm={3} md={1}>\n                  Empty\n              </Col>\n\n              <Col className=\"mb-1\" xs={4} sm={3} md={2}>\n                <Square\n                  index={0}\n                  value={5}\n                  onMouseEnter={() => console.log()}\n                  onMouseDown={() => console.log()}\n                  onMouseUp={() => console.log()}\n                />\n\n              </Col>\n              <Col xs={4} sm={3} md={1}>\n                  Visited\n              </Col>\n\n              <Col className=\"mb-1\" xs={4} sm={3} md={2}>\n                <Square\n                  index={0}\n                  value={4}\n                  onMouseEnter={() => console.log()}\n                  onMouseDown={() => console.log()}\n                  onMouseUp={() => console.log()}\n                />\n\n              </Col>\n              <Col xs={4} sm={3} md={1}>\n                  Path\n              </Col>\n\n\n\n\n\n\n            <Col className=\"mb-1\" xs={4} sm={3} md={2}>\n              <Square\n                index={0}\n                value={3}\n                onMouseEnter={() => console.log()}\n                onMouseDown={() => console.log()}\n                onMouseUp={() => console.log()}\n              />\n\n            </Col>\n            <Col xs={4} sm={3} md={1}>\n                Wall\n            </Col>\n\n\n\n\n\n\n          </Row>\n\n\n        </div>\n\n      </div>\n\n    );\n  }\n}\n\nexport default Key;\n\n\n/*\n<Row className=\"mb-2\">\n  <Col xs={24} lg={24}>\n      <p className=\"text-small\"> Click and drag to move source and target squares</p>\n      <p className=\"text-small\"> Click and/or drag to place walls in the grid</p>\n\n  </Col>\n</Row>\n*/\n","\nimport React from \"react\";\nimport {\n  Navbar,\n  NavbarBrand,\n  Nav,\n  NavItem,\n  NavLink,\n} from \"shards-react\";\n\nimport './Header.css';\nimport logo from './path_icon_white.png';\n\n\n/**\n * Class representing header that is shown at the top of the screen.\n */\nclass Header extends React.Component {\n\n  /**\n   * Renders header.\n   */\n  render() {\n    return (\n      <Navbar className=\"custom-navbar\" type=\"dark\" expand=\"md\">\n        <img className=\"d-inline-block align-top mr-3\" src={logo} width=\"30\" height=\"30\"  alt=\"\">\n        </img>\n        <NavbarBrand href=\"#\"> Pathfinding Algorithm Visualisation</NavbarBrand>\n          <Nav navbar className=\"ml-auto\">\n              <NavItem>\n                <NavLink active href=\"https://jasonpilbrough.github.io/\">\n                  <b className=\"hide-on-sm\"> <u> more projects... </u> </b>\n                </NavLink>\n              </NavItem>\n            </Nav>\n\n      </Navbar>\n    );\n  }\n}\n\n\nexport default Header;\n","import {dijkstra, a_star, depth_first, greedy_best_first} from './algorithms.js'\n\n\n/**\n * Class representing an individual vertex in a graph.\n */\nexport class Vertex{\n\n  /**\n   * Creates a vertex.\n   * @param {number} id - A unique identifier for the vertex.\n   * @param {number} isVisitable - Whether or not this vertex can be visited\n   * (cant be visited if a wall has been placed at this vertex).\n   */\n  constructor(id,isVisitable){\n    this.id = id;\n    this.fcost = null;    //cost (or distance) from source node to this node\n    this.hcost = null;    //heuristic cost - estimated cost to destination\n    this.prev = null;     //reference to parent vertex\n    this.edges = [];      //stores array of edges to neighbouring vertices\n    this.isVisitable = isVisitable\n  }\n\n  /**\n   * Returns the total cost associated with a vertex as the sum of fcost and\n   * hcost.\n   *\n   * @return {number} The total cost associated with a vertex\n   */\n  getTotalCost(){\n    if(this.fcost===null){\n      return null\n    }else{\n      return this.fcost + this.hcost\n    }\n  }\n\n}\n\n/**\n * Class representing the connection between vertices in a graph. Edges belong\n * to one specific vertex, and point to each vertex that is connected to the\n * current vertex.\n */\nexport class Edge{\n\n  /**\n   * Creates a Edge.\n   * @param {Vertex} neighbourVertex - The vertex that the edge is pointing to.\n   * @param {number} cost - The cost associated with traversing this edge (i.e.\n   * the distance between vertices).\n   */\n    constructor(neighbourVertex, cost){\n      this.neighbourVertex = neighbourVertex;\n      this.cost = cost;\n    }\n}\n\n\n/**\n * Class representing a set of connected vertices. Assumes underlying structure\n * is a square grid.\n */\nclass Graph{\n  /**\n   * Creates a Graph.\n   * @param {number} size - The number of vertices in the graph. Must be a\n   * square number.\n   * @param {number} sourceIndex - The index of the source vertex.\n   * @param {number} targetIndex - The index of the target vertex.\n   * @param {string} algorithm - The name of the algorithm to use for\n   * pathfinding. The accepted algorithms are: \"dijkstra\", \"a-star\",\n   * \"depth-first\" and \"greedy-best-first\".\n   */\n  constructor(size, sourceIndex, targetIndex, algorithm){\n    this.size = size;\n    this.sourceIndex = sourceIndex;\n    this.targetIndex = targetIndex;\n    this.algorithm = algorithm;\n\n    //mask indicating the positions of walls in the graph -   0 corresponds to\n    //no wall at a given index, 1 corresponds to wall at index\n    this.wallMask = Array(size).fill(0)\n\n    //generate a set of vertices and store them in a list\n    this.unprocessedVertices = this.build(this.wallMask, sourceIndex, targetIndex, algorithm);\n\n    //set distance to source vertex to 0\n    this.unprocessedVertices[sourceIndex].fcost=0\n\n    //list to store vertices after they have been visited/processed\n    this.processedVerticies = []\n\n    //stores where the pathfinding algorithm is finished. Will be true if a path\n    //has been found, or if no more vertices remain.\n    this.finished = false;\n\n    //weighting on a-star heuristic function - defaults to 1\n    this.eplison = 1\n  }\n\n  /**\n   * Builds vertex set.\n   * @param {number[]} wallmask - mask indicating the positions of walls in the\n   * graph -   0 corresponds to no wall at a given index, 1 corresponds to wall\n   * at index.\n   * @param {number} sourceIndex - The index of the source vertex.\n   * @param {number} targetIndex - The index of the target vertex.\n   * @param {string} algorithm - The name of the algorithm to use for\n   * pathfinding. The accepted algorithms are: \"dijkstra\", \"a-star\",\n   * \"depth-first\" and \"greedy-best-first\".\n   * @return {Vertex[]} Generated vertex set. Will return an empty set if no\n   * start or target index provided.\n   */\n  build(wallMask, sourceIndex, targetIndex, algorithm){\n\n    //if no sourceIndex or targetIndex is set return empty set []\n    if(sourceIndex===-1 || targetIndex===-1){\n      return []\n    }\n\n    //determine size of each row in the graph - assumes graph is square grid\n    const rowLength = Math.ceil(Math.sqrt(this.size))\n\n    const vertexSet = []\n    for(var i =0; i < this.size; i++){\n      let isVisitable\n      if(wallMask[i]===0 || i===targetIndex){ //no wall\n        isVisitable = true\n      }else{\n        isVisitable = false;\n      }\n\n      vertexSet.push(new Vertex(i,isVisitable))\n    }\n\n\n\n    //determine all neighbours, and compute hcost if applicable\n    for(var m = 0; m < vertexSet.length; m++){\n\n      //interpret m as bxb matrix\n      const rowIndex = Math.floor(m/rowLength)\n      const colIndex = m % rowLength\n\n      //loop over neighbouring vertexes (accounting for edge cases), and add to\n      //current vertex neighbour list\n      for(var n = Math.max(rowIndex-1,0); n <= Math.min(rowIndex+1, rowLength-1); n++){\n        for(var p = Math.max(colIndex-1,0); p <= Math.min(colIndex+1, rowLength-1); p++){\n\n          //dont want to add currentVertex as a neighbour to itself\n          if(n===rowIndex && p===colIndex){\n            continue;\n          }\n\n          //determine if current neighbour is connected to current Vertex by diagonal\n          const isDiagonal = n!==rowIndex && p!==colIndex\n          const neighbour = vertexSet[n*rowLength+p]\n\n          //only add to list of neighbours if able to visit\n          if(neighbour.isVisitable){\n              //diagonal has cost of sqrt(2) = 1.414\n              vertexSet[m].edges.push(new Edge(neighbour, isDiagonal ? 1.414 : 1))\n          }\n\n        }\n      }\n\n      //must add h-cost for a-star and greedy best first search algorithm - NB\n      //no eplison scaling factor for best-first\n      if(algorithm===\"a-star\"){\n        //interpret m as bxb matrix\n        const targetRowIndex = Math.floor(targetIndex/rowLength)\n        const targetColIndex = targetIndex % rowLength\n\n        //h-cost is calculated as straight line distance between current node\n        //and target node (ignoring walls)\n        const hcost = Math.sqrt(Math.pow(rowIndex-targetRowIndex,2)+Math.pow(colIndex - targetColIndex,2))\n        vertexSet[m].hcost = this.eplison * hcost\n\n      } else if(algorithm===\"greedy-best-first\"){\n        //interpret m as bxb matrix\n        const targetRowIndex = Math.floor(targetIndex/rowLength)\n        const targetColIndex = targetIndex % rowLength\n\n        //h-cost is calculated as straight line distance between current node\n        //and target node (ignoring walls)\n        const hcost = Math.sqrt(Math.pow(rowIndex-targetRowIndex,2)+Math.pow(colIndex - targetColIndex,2))\n        vertexSet[m].hcost = hcost //no eplison scaling factor\n      }\n    }\n\n    return vertexSet;\n  }\n\n\n  /**\n   * Processes the next vertex as determined by the selected pathfinding\n   * algorithm. Moves the processed vertex from unprocessedVertices set to\n   * processedVerticies set. Sets finished flag to true if path has been found\n   * or no more vertices ti process.\n   */\n  processNextVertex(){\n    if(this.finished){\n      console.log(\"All reachable verticies have already been processed\")\n      return null;\n    }\n\n    let nextClosestVertex =null\n\n    if(this.algorithm===\"a-star\"){\n        nextClosestVertex = a_star(this.unprocessedVertices)\n\n    } else if(this.algorithm===\"depth-first\"){\n        if(this.sourceIndex!==-1 && this.targetIndex!==-1){\n          //if this is the first time time this function is called, add source\n          //vertex\n          if(this.processedVerticies.length===0){\n            this.processedVerticies.push(this.unprocessedVertices[this.sourceIndex])\n          }\n          //pass the last vertex that was processed\n          nextClosestVertex = depth_first(this.processedVerticies[this.processedVerticies.length-1])\n        }\n\n    } else if(this.algorithm===\"greedy-best-first\"){\n        nextClosestVertex = greedy_best_first(this.unprocessedVertices)\n\n    } else { //else use dijkstra\n        nextClosestVertex = dijkstra(this.unprocessedVertices)\n    }\n\n\n    //happens if no path from source to target\n    if(nextClosestVertex===null){\n        this.finished=true;\n          console.log(\"No path from source to dest\")\n        return;\n    }\n\n    //if currentVertex is the target vertex, set isFinished to true\n    if(nextClosestVertex.id===this.targetIndex){\n      this.finished=true;\n    }\n\n    this.processedVerticies.push(nextClosestVertex)\n  }\n\n\n  /**\n   * Processes all vertices in set until path is found, or no more remaining\n   * vertices.\n   */\n  processAllVerticies(){\n    while(!this.isFinished()){\n      this.processNextVertex()\n    }\n  }\n\n  /**\n   * Returns true if target vertex has been reached, or no other verticies\n   * left to visit.\n   * @return {boolean} True if pathfinding algorithm has completed.\n   */\n  isFinished(){\n    return this.finished;\n  }\n\n\n  /**\n   * Returns a list of vertices on the path from the source vertex to the target\n   * vertex. Returns an empty list of no valid path.\n   * @return {Vertex[]} Vertices on path from source to target.\n   */\n  getPath(){\n    var processedVerticies = this.processedVerticies.slice();\n\n    //array with indices of vertices on shortest path to target\n    const pathToTarget = []\n\n    //use variable 't' to represent current vertex on path. Remove current\n    //vertex from list of processed vertices\n    var t = processedVerticies.pop()\n\n    //if t is underfined, no valid path, return empty list\n    if(t===undefined){\n      return []\n    }\n\n    //check if the target is on the path, if not then no path was found\n    if(t.id!==this.targetIndex){\n      return [];\n    }\n\n    //add vertex to path until source vertex is reached\n    while(t!==null){\n      pathToTarget.unshift(t.id)\n      t = t.prev\n    }\n\n    return pathToTarget\n  }\n\n  /**\n   * Converts graph into a sqaure grid representation to display. At each\n   * position in the grid a number is used to indicate the type of tile present.\n   * The available type are: 1=sourceTile, 2=targetTile, 3=wallTile, 4=pathTile\n   * 5=visitedTile.\n   * @return {Vertex[]} Square grid representation of graph\n   */\n  toGrid(){\n    var grid = Array(this.size).fill(0)\n\n    //show all walls\n    for(var j = 0; j<this.wallMask.length;j++){\n      if(this.wallMask[j]===1){\n          grid[j] = 3\n      }\n    }\n\n    //show all verticies that have been visited\n    for(var i = 0; i<this.processedVerticies.length; i++){\n      var currentVertex = this.processedVerticies[i].id;\n      grid[currentVertex] = 5\n    }\n\n    //show shortest path, if one was found\n    const pathToTarget = this.getPath()\n    if(pathToTarget!==null){\n      for(var k = 0; k<pathToTarget.length;k++){\n        const currentVertex = pathToTarget[k]\n        grid[currentVertex] = 4\n\n      }\n    }\n\n    //show source and target tiles\n    grid[this.sourceIndex] = 1\n    grid[this.targetIndex] = 2;\n\n    return grid\n\n  }\n\n  /**\n   * Returns all vertices to unprocessed state, but does not clear walls.\n   */\n  reset(){\n\n    //build new vertexSet\n    this.unprocessedVertices = this.build(this.wallMask, this.sourceIndex, this.targetIndex, this.algorithm);\n\n    //check if there is a start index set, and set distance to source vertex to 0\n    if(this.unprocessedVertices.length!==0){\n      this.unprocessedVertices[this.sourceIndex].fcost=0\n    }\n\n    this.processedVerticies = []\n    this.finished = false;\n\n  }\n\n  /**\n   * Clears all walls, and returns all vertices to unprocessed state.\n   */\n  clear(){\n    this.wallMask = Array(this.size).fill(0)\n    this.reset()\n  }\n\n  /**\n   * Changes the current algorithm being used for pathfinding.\n   * @param {string} algorithm - The name of the algorithm to use for\n   * pathfinding. The accepted algorithms are: \"dijkstra\", \"a-star\",\n   * \"depth-first\" and \"greedy-best-first\".\n   */\n  changeAlgorithm(algorithm){\n    this.algorithm = algorithm;\n    this.reset()\n    this.processAllVerticies()\n  }\n\n  /**\n   * Changes the value of epsilon used to weight the heuristic function for A*.\n   * @param {number} value - The new value for epsilon.\n   */\n  changeEpsilon(value){\n    this.eplison = value\n    this.reset()\n    this.processAllVerticies()\n  }\n\n  //\n  /**\n   * Handles the resize board, removing walls as neccessary, while attempting to\n   * maintaining position of source/target tiles. Returns all vertices to\n   * unprocessed state.\n   * @param {number} size - The new size of the graph. Must be a square number.\n   */\n  resize(size){\n\n    //keep record of previous size\n    const prevSize = this.size;\n\n    //update to new size\n    this.size = size;\n\n    //determine size of each row in the previous graph and the new graph -\n    //assumes graph is square grid\n    const prevRowLength = Math.ceil(Math.sqrt(prevSize))\n    const prevNumRows = prevRowLength //assumes square grid\n    const newRowLength = Math.ceil(Math.sqrt(size))\n    const newNumRows = newRowLength //assumes square grid\n\n    //determine row and column of target in previous grid\n    const prevTarget = this.targetIndex;\n    const prevTargetRow = Math.floor(prevTarget/prevRowLength)\n    const prevTargetCol = prevTarget%prevRowLength\n\n    //determine row and colum of target in new grid\n    const newTarget = prevTargetRow * newRowLength + prevTargetCol\n    const newTargetRow = Math.floor(newTarget/newRowLength)\n    const newTargetCol = newTarget%newRowLength\n\n    //check if new target is outside bounds of new board\n    if(prevTargetRow>=newRowLength && prevTargetCol>=newRowLength){\n      //if outside bound below AND to right of board\n      this.targetIndex = newRowLength * newRowLength -1\n    } else if(prevTargetRow>=newRowLength){\n      //if outside bound below board\n      this.targetIndex = (newRowLength-1) * newRowLength + newTargetCol\n    } else if(prevTargetCol>=newRowLength){\n      //if outside bound to right of board\n      this.targetIndex = (newTargetRow-1) * newRowLength + (newRowLength -1)\n    } else{\n      this.targetIndex = newTarget\n    }\n\n    //determine row and column of source in previous grid\n    const prevSource = this.sourceIndex;\n    const prevSourceRow = Math.floor(prevSource/prevRowLength)\n    const prevSourceCol = prevSource%prevRowLength\n\n    //determine row and colum of target in new grid\n    const newSource = prevSourceRow * newRowLength + prevSourceCol\n    const newSourceRow = Math.floor(newSource/newRowLength)\n    const newSourceCol = newSource%newRowLength\n\n    //check if new source is outside bounds of new board\n    if(prevSourceRow>=newRowLength && prevSourceCol>=newRowLength){\n      //if outside bound below AND to right of board\n      this.sourceIndex = newRowLength * newRowLength -1\n    } else if(prevSourceRow>=newRowLength){\n      //if outside bound below board\n      this.sourceIndex = (newRowLength-1) * newRowLength + newSourceCol\n    } else if(prevSourceCol>=newRowLength){\n      //if outside bound to right of board\n      this.sourceIndex = (newSourceRow-1) * newRowLength + (newRowLength -1)\n    } else{\n      this.sourceIndex = newSource\n    }\n\n    //check that source and target are on same square after resize\n    if(this.sourceIndex===this.targetIndex){\n      // if they are on same square, move source 1 square to left\n      this.sourceIndex -= 1\n    }\n\n    const newWallMask = Array(size).fill(0)\n\n    //update wallmask to remove walls that are no longer present.\n    for(var i = 0; i < newWallMask.length; i++){\n        const currentRowInNew = Math.floor(i/newRowLength)\n        const currentColInNew = i%newRowLength\n\n        if((currentColInNew+1)>prevRowLength){\n          newWallMask[i]=0 //if the current col was no present in prev grid, set mask to 0\n        }else if(this.wallMask[currentRowInNew*prevRowLength + currentColInNew]===1){\n          newWallMask[i]=1\n        }else{\n          newWallMask[i]=0\n        }\n    }\n\n    this.wallMask = newWallMask\n    this.reset()\n\n  }\n\n  /**\n   * Changes index of the source vertex in the grid. Returns all vertices to\n   * unprocessed state.\n   * @param {number} i - The new source vertex index.\n   */\n  changeSourceIndex(i){\n    this.sourceIndex = i\n    this.reset()\n    this.processAllVerticies()\n  }\n\n  /**\n   * Changes index of the target vertex in the grid. Returns all vertices to\n   * unprocessed state.\n   * @param {number} i - The new target vertex index.\n   */\n  changeTargetIndex(i){\n    this.targetIndex = i\n    this.reset()\n    this.processAllVerticies()\n  }\n\n\n  /**\n   * Updates the wallmask to indicate that a wall is present to the specified\n   * index in the grid. Re-processes all vertices.\n   * @param {number} i - The index of the new wall.\n   */\n  placeWall(i){\n\n    //do nothing if source or target square\n    if(i===this.sourceIndex || i===this.targetIndex){\n      return;\n    }\n\n    const wallMask = this.wallMask.slice();\n    wallMask[i] = 1\n    this.wallMask = wallMask\n\n    //must reset and recalc verticies\n    this.reset();\n    this.processAllVerticies()\n\n\n  }\n\n  /**\n   * Updates the wallmask to indicate that a wall is no longer present at the\n   * specified index in the grid. Re-processes all vertices.\n   * @param {number} i - The index of the wall to remove.\n   */\n  clearWall(i){\n    //do nothing if source or target square\n    if(i===this.sourceIndex || i===this.targetIndex){\n      return;\n    }\n\n    const wallMask = this.wallMask.slice();\n    wallMask[i] = 0\n    this.wallMask = wallMask\n\n    //must reset and recalc verticies\n    this.reset();\n    this.processAllVerticies()\n\n  }\n\n  /**\n   * Determines if a wall is present at a given index in the grid.\n   * @return {boolean} True if a wall is present at the given index.\n   */\n  isWall(i){\n\n    const wallMask = this.wallMask.slice();\n\n    if(wallMask[i] === 1){\n      return true\n    }else{\n      return false\n    }\n\n  }\n\n}\n\nexport default Graph;\n","/**\n * Provides the logic to determine the next vertex to visit from a set of\n * vertices according to various pathfinding algorithms. The algorithms that are\n * including are: Dijkstra, A*, Depth first search and Greedy best first search.\n *\n * @summary Provides implementation of various pathfinding algorithms.\n * @author Jason Pilbrough <jasonpilbrough@gmail.com>\n *\n * Start date     : 2019-12-19\n */\n\n\n /**\n  * @module algorithms\n  */\n\n\nimport Vertex from './graph.js'\nimport Edge from './graph.js'\n\n\n/**\n * Determines the next vertex to visit according to Dijkstra's algorithm.\n * Updates the distances to all neighbour vertices if a shorter route is found.\n *\n * @param {Vertex[]} unprocessedVertices - list of unvisited vertices\n * @return {Vertex} the next vertex to visit according to Dijkstra's algorithm\n */\nexport function dijkstra(unprocessedVertices){\n\n  //find index of next node to visit\n  var currentIndex = findIndexOfMinFcost(unprocessedVertices)\n\n  //if currentIndex === -1, no other vertex is reachable\n  if(currentIndex===-1){\n    return null;\n  }\n\n  //use variable 'u' to represent next vertex to visit\n  //remove vertex from vertexSet and store in u\n  var u = unprocessedVertices.splice(currentIndex,1)[0]\n\n  //loop over all neighbour vertices and update distances if better route is\n  //found\n  for(var j = 0; j < u.edges.length; j++){\n\n      //use variable 'v' for current edge\n      const v = u.edges[j]\n      const alt = u.fcost + v.cost\n\n      //check if neighbour hasnt been visited yet or if shorter route has been\n      //found\n      if(v.neighbourVertex.fcost==null || alt < v.neighbourVertex.fcost){\n        v.neighbourVertex.fcost = alt\n        v.neighbourVertex.prev = u\n      }\n  }\n\n  //return next vertex to visit\n  return u;\n}\n\n\n/**\n * Determines the next vertex to visit according to A*. Updates the distances\n * to all neighbour vertices if a shorter route is found.\n *\n * @param {Vertex[]} unprocessedVertices - list of unvisited vertices\n * @return {Vertex} the next vertex to visit according to A*\n */\nexport function a_star(unprocessedVertices){\n\n  //find index of next node to visit\n  var currentIndex = findIndexOfMinTotalCost(unprocessedVertices)\n\n  //if currentIndex === -1, no other vertex is reachable\n  if(currentIndex===-1){\n    return null;\n  }\n\n  //use variable 'u' to represent next vertex to visit\n  //remove vertex from vertexSet and store in u\n  var u = unprocessedVertices.splice(currentIndex,1)[0] //remove vertex from vertexSet and store in u\n\n\n  //loop over all neighbour vertices and update distances if better route is\n  //found\n  for(var j = 0; j < u.edges.length; j++){\n\n      //use variable 'v' for current edge\n      const v = u.edges[j]\n\n      //check if neighbour hasnt been visited yet or if shorter route has been\n      //found\n      const alt = u.fcost + v.cost\n      if(v.neighbourVertex.fcost==null || alt < v.neighbourVertex.fcost){\n        v.neighbourVertex.fcost = u.fcost + v.cost\n        v.neighbourVertex.prev = u\n      }\n  }\n\n  //return next vertex to visit\n  return u;\n}\n\n\n/**\n * Determines the next vertex to visit according to depth-first search algorithm.\n *\n * @param {Vertex} prevVertex - referance to previous vertex that was visited\n * @return {Vertex} the next vertex to visit according to depth-first search\n */\nexport function depth_first(prevVertex){\n\n    //may happen if no source or target index\n    if(prevVertex===undefined){\n      return null\n    }\n\n    var nextVertex = null\n\n    //iterate over each vertex of prevVertex, and visit first one that hasnt\n    //been visited yet\n    for(var j = 1; j< prevVertex.edges.length+1; j++){\n        // starting iteration with different value for j will determine which\n        // search direction is prefered\n        var i = j % prevVertex.edges.length\n\n        // check if neighbour has been visited before\n        if(prevVertex.edges[i].neighbourVertex.fcost===null){\n            nextVertex = prevVertex.edges[i].neighbourVertex\n\n            //assign a arbitary value of 1 to indicate vertex has been visited\n            nextVertex.fcost = 1\n\n            nextVertex.prev = prevVertex\n            return nextVertex\n        }\n    }\n\n    //at this point in the algorithm the path has reached a dead-end, so start\n    //backtracking until a vertex has another path to follow\n    var backtrackVertex = prevVertex.prev\n\n    //stop backtracking if returned back to source vertex\n    while(backtrackVertex!==null){\n\n      //iterate over each vertex of currentVertex, and visit first one that\n      //hasnt been visited yet\n      for(var j = 1; j< backtrackVertex.edges.length+1; j++){\n\n          //do this to control which search direction is prefered\n          var i = j% backtrackVertex.edges.length\n\n          // check if neighbour has been visited before\n          if(backtrackVertex.edges[i].neighbourVertex.fcost===null){\n              nextVertex = backtrackVertex.edges[i].neighbourVertex\n              //assign a arbitary value of 1 to indicate vertex has been visited\n              nextVertex.fcost = 1\n              nextVertex.prev = backtrackVertex\n              return nextVertex\n          }\n      }\n\n      //if no unvisited vertex was found, backtrack up another level to parent\n      backtrackVertex = backtrackVertex.prev\n    }\n\n    //if algorithm reaches here, no more paths to explore, return null\n    return nextVertex\n}\n\n/**\n * Determines the next vertex to visit according to greedy_best_first algorithm.\n *\n * @param {Vertex[]} unprocessedVertices - list of unvisited vertices\n * @return {Vertex} the next vertex to visit according to be greedy best first search\n */\nexport function greedy_best_first(unprocessedVertices){\n\n  //find index of next vertex to visit\n  var currentIndex = findIndexOfMinHCost(unprocessedVertices)\n\n  //if currentIndex === -1, no other vertex is reachable\n  if(currentIndex===-1){\n    return null;\n  }\n\n  //use variable 'u' to represent next vertex to visit\n  //remove vertex from vertexSet and store in u\n  var u = unprocessedVertices.splice(currentIndex,1)[0] //remove vertex from vertexSet and store in u\n\n  //loop over all neighbour vertices and mark all neighbour as reachable by\n  //setting fcost=1\n  for(var j = 0; j < u.edges.length; j++){\n\n      //use variable 'v' for current edge\n      const v = u.edges[j]\n\n      //check if neighbour hasnt been visited yet\n      if(v.neighbourVertex.fcost===null){\n        v.neighbourVertex.fcost = 1 //indicates vertex has been visited\n        v.neighbourVertex.prev = u\n      }\n  }\n\n  //return next vertex to visit\n  return u;\n}\n\n\n/**\n * Determines the index of a vertex in a set with the lowest fcost (i.e the\n * shortest distance to the source vertex)\n *\n * @param {Vertex[]} vertexSet - set of vertices to search\n * @return {Vertex} the vertex with the lowest fcost\n */\nfunction findIndexOfMinFcost(vertexSet){\n\n    //initialise to some large number\n    var minDist = 1000000000;\n\n    //if -1 is returned, no min vertex was found\n    var indexOfMin = -1\n\n    for(var i=0; i < vertexSet.length; i++){\n      const dist = vertexSet[i].fcost\n\n      //dont consider distance if it is null\n      if(dist===null){\n        continue;\n      }\n\n      if(dist< minDist){\n        minDist = dist\n        indexOfMin = i\n      }\n    }\n\n    return indexOfMin\n}\n\n\n/**\n * Determines the index of a vertex in a set with the lowest total cost (i.e the\n * sum of fcost and hcost)\n *\n * @param {Vertex[]} vertexSet - set of vertices to search\n * @return {Vertex} the vertex with the lowest total cost\n */\nfunction findIndexOfMinTotalCost(vertexSet){\n\n    //initialise to some large number\n    var minDist = 1000000000;\n\n    //if -1 is returned, no min vertex was found\n    var indexOfMin = -1\n\n    for(var i=0; i < vertexSet.length; i++){\n      const dist = vertexSet[i].getTotalCost()\n\n      //dont consider distance if it is null\n      if(dist===null){\n        continue;\n      }\n      if(dist< minDist){\n        minDist = dist\n        indexOfMin = i\n      }\n    }\n\n    return indexOfMin\n}\n\n\n/**\n * Determines the index of a vertex in a set with the lowest hcost (i.e the\n shortest distance to the target vertex)\n *\n * @param {Vertex[]} vertexSet - set of vertices to search\n * @return {Vertex} the vertex with the lowest hcost\n */\nfunction findIndexOfMinHCost(vertexSet){\n\n    //initialise to some large number\n    var minDist = 1000000000;\n\n    // if -1 is returned, no min vertex was found\n    var indexOfMin = -1\n\n    for(var i=0; i < vertexSet.length; i++){\n      const dist = vertexSet[i].fcost\n\n      //dont consider distance if it is null\n      if(dist===null){\n        continue;\n      }\n\n      const hcost = vertexSet[i].hcost\n      if(hcost< minDist){\n        minDist = hcost\n        indexOfMin = i\n      }\n    }\n\n    return indexOfMin\n}\n","import React from 'react';\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport \"shards-ui/dist/css/shards.min.css\"\nimport { Container, Row, Col, Nav, NavItem, NavLink, Navbar} from \"shards-react\";\nimport './App.css';\nimport Board from './Board.js';\nimport ControlPanel from './ControlPanel.js';\nimport Key from './Key.js';\nimport Header from './Header.js';\nimport Graph from './graph.js'\nimport { BrowserView,MobileView } from \"react-device-detect\";\n\n\n/**\n * Class representing pathfinding algorithm application. Brings together all UI\n * elements including the game board, the control panel, header, etc.\n */\nclass App extends React.Component {\n\n  /**\n   * Creates the app.\n   */\n  constructor(props){\n    super(props)\n\n    //indices representing source vertex and target vertex\n    const sourceIndex = 104\n    const targetIndex = 286\n\n    //number of vertices in grid - NB must be a square number\n    const defaultNumSquares = 625\n\n    //create graph and process all vertices on startup\n    var graph = new Graph(defaultNumSquares,sourceIndex,targetIndex, \"dijkstra\")\n    graph.processAllVerticies()\n\n    this.state = {\n          graph: graph,\n          sourceIndex: sourceIndex,\n          targetIndex: targetIndex,\n          isSourceMoving: false, //is the source currently being moved by the user\n          isTargetMoving: false, //is the target currently being moved by the user\n    };\n\n  }\n\n\n  /**\n   * Animate the process of finding the path from source to target by processing\n   * vertices one by one and updating the game board in between. This function\n   * calls itself repeatedly until complete.\n   *\n   * @param {Graph} graph - The graph representing the grid.\n   */\n  animateSteps(graph){\n\n    //process next vertex, and then cause refresh by updating state\n    graph.processNextVertex()\n    this.setState(this.state);\n\n    //call this function repeatedly until path is found, or no more vertices.\n    if(!graph.isFinished()){\n      //this is essential to allow board a chance to update between steps,\n      //think of this as a yield\n      new Promise((resolve) => setTimeout(resolve, 0)).then(() => {\n        this.animateSteps(graph)\n      });\n    }\n  }\n\n  /**\n   * Handle when the mouse down event occures. Allows the source and target\n   * tile to enter move mode when applicable. This will cause source/ target to\n   * move to position of mouse, until mouse is released.  Else places/clears\n   * walls.\n   *\n   * @param {number} i - Index of position in grid where event occured.\n   */\n  handleMouseDown(i){\n    const squares = this.state.graph.toGrid()\n\n    if(squares[i]===1){ //source tile\n      this.setState({\n        graph: this.state.graph,\n        sourceIndex: this.state.sourceIndex,\n        targetIndex: this.state.targetIndex,\n        isSourceMoving: true,\n        isTargetMoving: this.state.isTargetMoving,\n\n      });\n    } else if(squares[i]===2){ //target tile\n      this.setState({\n        graph: this.state.graph,\n        sourceIndex: this.state.sourceIndex,\n        targetIndex: this.state.targetIndex,\n        isSourceMoving: this.state.isSourceMoving,\n        isTargetMoving: true\n      });\n    } else { // pace or clear wall\n      if(this.state.graph.isWall(i)){\n        this.state.graph.clearWall(i)\n      }else{\n          this.state.graph.placeWall(i)\n      }\n\n      this.setState({\n        graph: this.state.graph,\n        sourceIndex: this.state.sourceIndex,\n        targetIndex: this.state.targetIndex,\n        isSourceMoving: this.state.isSourceMoving,\n        isTargetMoving: this.state.isTargetMoving,\n        //indicate if a wall has been placed, will continue to try and place walls until mouse is released\n        placementIsWall: this.state.graph.isWall(i)\n      });\n    }\n\n\n  }\n\n /**\n  * Handles the mouse enter event. This occures when the cursor enters a\n  tile while the mouse is held down. This has the effect of either, moving the\n  * source/target to the current tile, or placing/clearing a wall.\n  *\n  * @param {number} i - Index of position in grid where event occured.\n  */\n  handleMouseEnter(i){\n    if(this.state.isSourceMoving){\n        this.state.graph.changeSourceIndex(i)\n    } else if(this.state.isTargetMoving){\n        this.state.graph.changeTargetIndex(i)\n    } else {\n        if(this.state.placementIsWall===true){\n          this.state.graph.placeWall(i)\n        }else{\n          this.state.graph.clearWall(i)\n        }\n    }\n    this.setState(this.state);\n  }\n\n  /**\n   * Handles when the mouse released event. This has the effect of ending\n   * source/target move mode if applicable.\n   *\n   * @param {number} i - Index of position in grid where event occured.\n   */\n  handleMouseUp(i){\n    if(this.state.isSourceMoving){\n        this.setState({\n          graph: this.state.graph,\n          sourceIndex: this.state.sourceIndex,\n          targetIndex: this.state.targetIndex,\n          isSourceMoving: false,\n          isTargetMoving: this.state.isTargetMoving,\n        });\n    } else if(this.state.isTargetMoving){\n        this.setState({\n          graph: this.state.graph,\n          sourceIndex: this.state.sourceIndex,\n          targetIndex: this.state.targetIndex,\n          isSourceMoving: this.state.isSourceMoving,\n          isTargetMoving: false\n        });\n    } else{\n      this.setState(this.state);\n    }\n  }\n\n\n  /**\n   * Handle when mobile device screen is touched. This replaces all mouse events\n   * when on mobile, as provides similar functionality. On mobile it is not\n   * possible to touch and drag to move source/target or place/clear walls.\n   * Thus, to move source/target first touch source/target, it will disappear\n   * tempararily from the game board, then tap a new location to replace.\n   *\n   * @param {number} i - Index of position in grid where event occured.\n   */\n  handleTouchStart(i){\n\n    if(this.state.isSourceMoving){\n        this.state.graph.changeSourceIndex(i)\n        this.setState({\n          graph: this.state.graph,\n          sourceIndex: this.state.sourceIndex,\n          targetIndex: this.state.targetIndex,\n          isSourceMoving: false,\n          isTargetMoving: this.state.isTargetMoving,\n        });\n    } else if (this.state.isTargetMoving){\n        this.state.graph.changeTargetIndex(i)\n        this.setState({\n          graph: this.state.graph,\n          sourceIndex: this.state.sourceIndex,\n          targetIndex: this.state.targetIndex,\n          isSourceMoving: this.state.isSourceMoving,\n          isTargetMoving: false\n        });\n    }else{\n\n      const squares = this.state.graph.toGrid()\n      if(squares[i]===1){\n        this.state.graph.changeSourceIndex(-1)\n        this.setState({\n          graph: this.state.graph,\n          sourceIndex: this.state.sourceIndex,\n          targetIndex: this.state.targetIndex,\n          isSourceMoving: true,\n          isTargetMoving: this.state.isTargetMoving,\n\n        });\n      } else if(squares[i]===2){\n        this.state.graph.changeTargetIndex(-1)\n        this.setState({\n          graph: this.state.graph,\n          sourceIndex: this.state.sourceIndex,\n          targetIndex: this.state.targetIndex,\n          isSourceMoving: this.state.isSourceMoving,\n          isTargetMoving: true\n        });\n      } else {\n          if(this.state.graph.isWall(i)){\n              this.state.graph.clearWall(i)\n          }else{\n              this.state.graph.placeWall(i)\n          }\n\n          this.setState({\n            graph: this.state.graph,\n            sourceIndex: this.state.sourceIndex,\n            targetIndex: this.state.targetIndex,\n            isSourceMoving: this.state.isSourceMoving,\n            isTargetMoving: this.state.isTargetMoving,\n            //indicate if a wall has been placed, will continue to try and place walls until mouse is released\n            placementIsWall: this.state.graph.isWall(i)\n          });\n      }\n\n    }\n\n\n  }\n\n  /**\n   * Handle when current pathfinding algorithm is changed in the UI. Updates\n   * the graph accordingly.\n   *\n   * @param {string} algorithm - Name of the new algorithm in use.\n   */\n  handleAlgorithmChange(algorithm){\n      this.state.graph.changeAlgorithm(algorithm)\n      this.setState(this.state);\n  }\n\n  /**\n   * Handle when epsilon value is changed in the UI. Updates the graph\n   * accordingly.\n   *\n   * @param {number} value - New value for epsilon.\n   */\n  handleEpsilonChange(value){\n    this.state.graph.changeEpsilon(value)\n    this.setState(this.state);\n  }\n\n  /**\n   * Handle when run button is pressed in UI. First reset graph, and then start\n   * animation.\n   */\n  handleRunPressed(){\n      this.state.graph.reset()\n      this.animateSteps(this.state.graph)\n  }\n\n\n  /**\n   * Handle when reset button is pressed in UI. First clear game board, then\n   * re-process all vertices.\n   */\n  handleResetPressed(){\n\n    const graph = this.state.graph\n\n    //const sourceIndex = 0\n    //const targetIndex = 208\n\n    //graph.changeSourceIndex(sourceIndex)\n    //graph.changeTargetIndex(targetIndex)\n    graph.clear();\n    graph.processAllVerticies()\n\n    this.setState(this.state);\n\n  }\n\n  /**\n   * Handle when screen is resized. First calculate the space available for\n   * grid, then update graph accordingly.\n   */\n  handleScreenResize() {\n    console.log(window.innerWidth)\n    let maxCols;\n    if(window.innerWidth>768){\n      maxCols = 25;\n    }else{\n      maxCols = 22\n    }\n\n    const numCols = Math.min(Math.round((window.innerWidth-50)/23.0),maxCols)\n\n    //NB numSquares must be a square number\n    const numSquares = Math.pow(numCols,2)\n\n    this.state.graph.resize(numSquares)\n    this.state.graph.processAllVerticies()\n\n    this.setState(this.state);\n  }\n\n\n  //Add event listener for window resize\n  componentDidMount() {\n    this.handleScreenResize();\n    window.addEventListener(\"resize\", this.handleScreenResize.bind(this));\n  }\n\n  //Remove event listener  for window resize\n  componentWillUnmount() {\n    window.removeEventListener(\"resize\", this.handleScreenResize.bind(this));\n  }\n\n\n  /**\n   * Renders application.\n   */\n  render() {\n    return (\n\n      <div className=\"App\">\n        <Header/>\n\n        <Container className=\"mt-3\">\n\n          <Row>\n            <Col className=\"order-1 order-lg-1\" md=\"12\" lg=\"4\">\n                <Row className=\"mb-4\">\n                  <Col >\n                    <ControlPanel\n                      onRunPressed={() => this.handleRunPressed()}\n                      onResetPressed={() => this.handleResetPressed()}\n                      onAlgorithmChange={(algorithm) => this.handleAlgorithmChange(algorithm)}\n                      onEpsilonChange={(value) => this.handleEpsilonChange(value)}\n                    />\n                  </Col>\n                </Row>\n\n            </Col>\n            <Col className=\"order-2 order-lg-2\" md=\"12\" lg=\"8\" >\n              <Row>\n                <Col>\n                  <BrowserView>\n                    <Board\n                        squares={this.state.graph.toGrid()}\n                        onMouseDown={(i) => this.handleMouseDown(i)}\n                        onMouseEnter={(i) => this.handleMouseEnter(i)}\n                        onMouseUp={(i) => this.handleMouseUp(i)}\n                    />\n                  </BrowserView>\n\n                  <MobileView>\n                    <Board\n                        squares={this.state.graph.toGrid()}\n                        onMouseDown={(i) => this.handleTouchStart(i)}\n                        onMouseEnter={(i) => console.log()}\n                        onMouseUp={(i) => console.log()}\n                    />\n                  </MobileView>\n                </Col>\n              </Row>\n\n\n              <Row className=\"mt-2\">\n                <Col>\n                  <Key />\n                </Col>\n              </Row>\n\n            </Col>\n          </Row>\n\n\n        </Container>\n        <Navbar className=\"custom-footer hide-on-md\" type=\"dark\" expand=\"md\">\n          <Nav navbar fill className=\"custom-footer ml-auto mr-auto\" type=\"dark\">\n            <NavItem>\n              <NavLink active href=\"https://jasonpilbrough.github.io/\">\n                <b className=\"\"> <u> Click here for more projects... </u> </b>\n              </NavLink>\n            </NavItem>\n          </Nav>\n        </Navbar>\n      </div>\n\n\n    );\n  }\n}\n\nexport default App;\n\n\n/*\n<header className=\"App-header\">\n  <img src={logo} className=\"App-logo\" alt=\"logo\" />\n  <p>\n    Edit <code>src/App.js</code> and save to reload.\n  </p>\n  <a\n    className=\"App-link\"\n    href=\"https://reactjs.org\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    Learn React\n  </a>\n</header>\n*/\n\n\n/*\n  updatePath(vertexSet,squares, sourceIndex, targetIndex){\n\n    //clear any previous paths and visited squares\n    for(var j = 0; j<squares.length; j++){\n      if(squares[j]===4 || squares[j]===5){\n          squares[j] = 0\n      }\n    }\n\n    while(!vertexSet.isFinished()){\n      const nextSquare = vertexSet.processNextVertex()\n\n      //dont change source and target squares\n      if(nextSquare===sourceIndex || nextSquare===targetIndex){\n        continue;\n      }\n      squares[nextSquare] = 5;\n    }\n\n    return squares;\n\n    /*\n    //clear any previous paths and visited squares\n    for(var j = 0; j<squares.length; j++){\n      if(squares[j]===4 || squares[j]===5){\n          squares[j] = 0\n      }\n    }\n    const returnVal = dijkstra(squares, sourceIndex, targetIndex)\n\n    const visitedSquares = returnVal[0]\n    const path = returnVal[1]\n\n    console.log(visitedSquares)\n    for(var i = 0; i<visitedSquares.length ; i++){\n      if(visitedSquares[i]===sourceIndex || visitedSquares[i]===targetIndex){\n        continue;\n      }\n      squares[visitedSquares[i]]=5;\n    }\n\n    //only update squares if a valid path was found\n    if(path.length!==0){\n      //skip first and last indices as they contain start and end\n      for(var k = 1; k<path.length -1 ; k++){\n        squares[path[k]] = 4\n      }\n    }\n\n    return squares\n\n  }\n\n  */\n\n  /*\n  changeSquare(i){\n    const squares = this.state.squares.slice()\n    //if square is empty or contains a path, or has been visited -> add a wall, otherwise clear\n    if(squares[i]===0||squares[i]===4||squares[i]===5){\n        squares[i] = 3\n    } else if (squares[i] === 3){\n        squares[i] = 0\n    }\n\n    this.setState({\n      squares: squares\n    });\n\n  }\n  */\n\n  /*\n\n  <Col className=\"order-3 col-12 mt-4 hidden-md\"  >\n      <Key\n      />\n  </Col>\n  */\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}